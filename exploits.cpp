/**********************************************************************
* Program:
*   Lab 08, Vulnerabilities and Exploits
*   Brother Wilson, CSE453
*
* Authors:
*   Timothy Bohman
*   Alex Johnson
*   John Batty
*   Abdias Baldiviezo Aguilar
*
* Summary:
*   This program demonstrates 7 types of vulnerabilities that are
*   exploitable by malicious user input, which is simulated here by
*   functions that feed the input values into the vulnerable functions.
*
* Sources:
*   Helfrich, J. "Security for Software Engineers", Chapter 4, BYU-Idaho, 2019.
*     [Online] Available:
*     https://content.byui.edu/file/aef44313-1018-4be3-ae4c-78c3a9eab926/1/Security%20for%20Software%20Engineers.pdf
*
*************************************************************************/
#include <iostream>
#include <sstream>
#include <string.h>
#include <stringapiset.h>
using namespace std;

#define arraySize 4

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(int index, unsigned int value)
{

    unsigned int array[arraySize];
    bool authenticated = false;

    array[index] = value;

    cout << "Array Content at index " << index << " has been changed to " << value << endl;

    for(int i = 0; i < arraySize + 1; i++ ) {
        cout << "Array at Index " << i << ": " << array[i] << endl;
    }
    
    if(authenticated) {
        cout << "Welcome! You have successfully been authenticated" << endl;
    }
    else {
        cout << "You are not authenticated." << endl;
    }


}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
   arrayVulnerability(1,256);
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
   arrayVulnerability(arraySize, 4294967295);
}

void safe() {

   cout << "You are totally safe here" << endl;

}

void dangerous() {

   cout << "All of your bases are belonged to us." << endl;

}

/*************************************
 * ARC VULNERABILTY
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input to
 *    overwrite the function pointer. This typically happens through a stack
 *    buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must be
 *    dereferenced.
 ****************************************/
void arcVulnerability(int index, long input)
{
   //stringstream ss(input);
   //stringstream ss("123");
   //ss << input;
   long buffer[4];
   void (* pointerFunction)() = safe;
   buffer[index] = input; // input references pointerFunction
   pointerFunction(); // here we are not executing safe()

}

/**************************************
 * ARC WORKING
 * Call arcVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arcWorking()
{
   arcVulnerability(1, 123456);
}

/**************************************
 * ARC EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing unintended access to
 *    the function pointer.
 * 2. The attacker must have the address to another function which is to be
 *    used to replace the existing function pointer.
 *************************************/
void arcExploit()
{
   long input;
   cout << "Address of dangerous: " << (void *)dangerous << endl;

   input = (long)(void *)dangerous;

   arcVulnerability(4, input);
}


/****************************************************************************************************************
 * Vulnerable class and the derived class, Vulnerability
 * *************************************************************************************************************/
class Vulnerable
{
   friend class Vulnerability;
   public:
      virtual void set(int index, long value) {
         cout << "Non-virtual set()" << endl;
      }; // polymorphic function
      virtual void dangerous(int index, long value) {
         cout << "Non-virtual dangerous()" << endl;
      }; // polymorphic function
      void displayBuffer(int index)
      {
         cout << "buffer[" << index << "] = " << buffer[index] << endl;
         cout << "buffer[" << index << "] address: " << &buffer[index] << endl;
      }
      long getBufferAddress(int index)
      {
         return (long)&buffer[index];
      }
   private:
      long buffer[1]; // an array in the class that has a buffer overrun vulnerability
};

class Vulnerability: public Vulnerable
{
   public:
      void set(int index, long value)
      { // set the buffer[index] value without checking for buffer overruns
         buffer[index] = value;
      }
      void dangerous(int index, long value)
      {
         cout << "DANGER! Function swapped!" << endl;
      }
};

typedef void (Vulnerable::*VulnerableSet)(int index, long value);

/*************************************
 * V-TABLE VULNERABILTY
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for user input to
 *    overwrite parts of the V-Table.
 * 4. After a virtual function pointer is overwritten, the virtual function must
 *    be called.
 ****************************************/
void vtableVulnerability(Vulnerability &test, int index, long value)
{
   test.set(index, value);
}

/**************************************
 * V-TABLE WORKING
 * Call arcVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void vtableWorking()
{
   Vulnerability test;
   int index = 0;
   long value = 28;
   vtableVulnerability(test, index, value);
   test.displayBuffer(index);
}

/**************************************
 * V-TABLE EXPLOIT
 * 1. Through some vulnerability, the V-Table pointer or a function pointer
 *    within the V-Table must be overwritten.
 * 2. The attacker must have the address to another V-Table pointer or a
 *    function pointer.
 *************************************/
void vtableExploit()
{
   Vulnerability test;
   int validIndex = 0;
   int invalidIndex = 5;
   long dummyExploitValue = 256;

   VulnerableSet vDangerousFunctionPointer;
   vDangerousFunctionPointer = &Vulnerable::dangerous;
   long vDangerousFunctionAddress = (long)&vDangerousFunctionPointer;
   
   VulnerableSet vSetFunctionPointer;
   vSetFunctionPointer = &Vulnerable::set;
   long vSetFunctionAddress = (long)&vSetFunctionPointer;
   
   cout << "Address of set: " << vSetFunctionAddress << endl;
   cout << "Address of dangerous: " << vDangerousFunctionAddress << endl;
   long bufferAddress = test.getBufferAddress(validIndex);
   long exploitBufferIndex = (bufferAddress - vSetFunctionAddress) / 8;
   vtableVulnerability(test, exploitBufferIndex, vDangerousFunctionAddress);
   vtableVulnerability(test, validIndex, dummyExploitValue);

   cout << "Maximum legal buffer index: " << validIndex << endl;
   cout << "V-Table buffer exploited index: " << exploitBufferIndex << endl;
   test.displayBuffer(validIndex);
   test.displayBuffer(exploitBufferIndex);
}

/****************************************************************************************************************
 * 
 * *************************************************************************************************************/
/*************************************
 * STACK VULNERABILTY
 * 1. There must be a buffer (such as an array) on the stack.
 * 2. The buffer must be reachable from an external input.
 * 3. The mechanism to fill the buffer from the external input must not
 *    correctly check for the buffer size.
 * 4. The buffer must be overrun (extend beyond the intended limits of the
 *    array).
 ****************************************/
void stackVulnerability(long int input[], int size)
{
   int i = 0;
	long int buffer[2];

	cout << "The new buffer is: ";

	for (i = 0; i < size; i++)
	{
		buffer[i] = input[i];
		cout << buffer[i];
	}
	cout << endl;
}

/**************************************
 * STACK WORKING
 * Call arcVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void stackWorking()
{
	long int buffer[2] = { 0, 0 };
	stackVulnerability(buffer, (sizeof(buffer) / sizeof(buffer[0])));
}


/**************************************
 * STACK EXPLOIT
 * 1. The attacker must provide more data into the outwardly facing buffer
 *    than the buffer is designed to hold.
 * 2. The attacker must know where the stack pointer resides on the stack.
 *    This should be just beyond the end of the buffer.
 * 3. The attacker must insert machine language instructions in the buffer.
 *    This may occur before, after, or even around the stack pointer. The
 *    machine language could be already compiled code in the program.
 * 4. The attacker must overwrite the stack pointer. The old value, directing
 *    the flow of the program after the function is returned, must be changed
 *    from the calling function to the provided machine language in step 3.
 *************************************/
void stackExploit()
{
	cout << "Launching stack exploit..." << endl;
	long int buffer[12] = { 0, 0, 0, 0, 0, 0, (long int)&dangerous };
	stackVulnerability(buffer, 8);

	cout << "Returned to stackExploit(). Exploit missed!" << endl;
}

/****************************************************************************************************************
 * 
 * *************************************************************************************************************/
/*************************************
 * HEAP VULNERABILTY
 * 1. There must be two adjacent heap buffers.
 * 2. The first buffer must be reachable through external input.
 * 3. The mechanism to fill the buffer from the external input must not
 *    correctly check for the buffer size.
 * 4. The second buffer must be released before the first.
 * 5. The first buffer must be overrun (extend beyond the intended limits of
 *    the array).
 ****************************************/
void heapVulnerability(char* input, int length)
{
   char *text1 = new char[4];
   char *text2 = new char[4];
   for (int i = 0; i < length; i++) {
      *(text1 + i) = *(input + i);
   }
   delete [] text2;
}

/**************************************
 * HEAP WORKING
 * Call heapVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void heapWorking()
{
   char text [] = "foo";
   char * input = text;
   heapVulnerability(input, 4);
}

/**************************************
 * HEAP EXPLOIT
 * 1. The attacker must provide more data into the outwardly facing heap
 *    buffer than the buffer is designed to hold.
 * 2. The attacker must know the layout of the Memory Control Block (MCB)
 *    (essentially a linked list) residing just after the buffer.
 * 3. The attacker must provide a new MCB containing both the location of
 *    the memory overwrite and the new data to be overwritten.
 *************************************/
void heapExploit()
{
   char text [] = "123456789012345678901234567890123456789012345678901234567890123This is some Gnarly Heap Spraying. We're going to the moon and back with how long this string of text is.We're going to keep going until this whole thing crashes to the ground in a firey explosion of death and mayhem.";
   char * input = text;
   heapVulnerability(input, 281);
}

/****************************************************************************************************************
 * 
 * *************************************************************************************************************/
/*************************************
 * INTEGER VULNERABILTY
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel must be
 *    reachable through external input. This sentinel is a variable used to make
 *    the security decision from the first requirement.
 ****************************************/
void integerVulnerability(unsigned int x)
{
   unsigned int y = 1001;
   cout << "You have $" << x << " in your first account: " << endl;
   cout << "You have $" << y << " in your second account: " << endl;
   // max size of unsigned int 4,294,967,295
   //2147483647.5 half of the max size of an unsigned int
   int balance = x + y;
      cout << "you have $" << (balance) << " in your 2 accounts combined." << endl;   

   if (balance < 1000) {
      cout << "Access Granted! Welcome to the broke college kid club." << endl;
   }
   else {
      cout << "Access Denied. Only poor people allowed." << endl;
   }
}

/**************************************
 * INTEGER WORKING
 * Call arcVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void integerWorking()
{
   unsigned int x = 250234;
   integerVulnerability(x);
}

/**************************************
 * INTEGER EXPLOIT
 * 1. Provide input, either a buffer size or a single value, that is directly or
 *    indirectly used in the vulnerable expression.
 * 2. The input must exceed the valid bounds of the data-type, resulting in an
 *    overflow or underflow condition.
 *************************************/
void integerExploit()
{
   unsigned int x = 4294966296;
   integerVulnerability(x);
}

/****************************************************************************************************************
 * 
 * *************************************************************************************************************/
/*************************************
 * ANSI_UNICODE CONVERSION VULNERABILTY
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer rather than the
 *    number of elements in the buffer.
 ****************************************/
void ansiVulnerability(string password, string password_from_db)
{
   cout << "user-provided password is \"" << password 
         << "\" & database password is \"" 
         << password_from_db << "\"" << endl;
   try
   {
      WCHAR target[12];
      MultiByteToWideChar(
               CP_ACP,
               0,
               password.c_str(),
               -1,        
               target,        
               sizeof(target));
      //cout << "size " << sizeof(target) << endl;
      WCHAR target2[12];
      MultiByteToWideChar(
               CP_ACP,
               0,
               password_from_db.c_str(),
               -1,        
               target2,        
               sizeof(target2));
      //cout << "size " << sizeof(target2) << endl;
      if (sizeof(target) == sizeof(target2)) {
      cout <<"you are logged in!" << endl;
      }
      else
      {
         cout << "failed login!" << endl;
      }
   }
   catch(char* str)
   {
      cout << "buffer overrun" << '\n';
      return;
   }
      
   
}

/**************************************
 * ANSI_UNICODE CONVERSION WORKING
 * Call arcVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking()
{
   ansiVulnerability("realpassword","realpassword");
}

/**************************************
 * ANSI_UNICODE CONVERSION EXPLOIT
 * 1. The attacker must provide more than half as much data into the
 *    outwardly facing buffer as it is designed to hold.
 * 2. From here, a variety of injection attacks are possible. The most likely
 *    candidates are stack smashing or heap smashing. In the above example,
 *    the third parameter of the copyUnicodeText() function is the number
 *    of elements in the string (256 elements), not the size of the string (512
 *    bytes). The end result is a buffer overrun of 256 bytes
 *************************************/
void ansiExploit()
{
   ansiVulnerability("supersuperFakePassword","realpassword");
}



/**************************************
 * MAIN
 * 
 *************************************/
int main() {
    
   char exploitTypeOption = '0';
   while (exploitTypeOption != '8') {
      cout << "Which type of exploit demonstration do you want to see?" << endl;
      cout << "1. Array Index\n";
      cout << "2. Arc Injection\n";
      cout << "3. V-Table Spraying\n";
      cout << "4. Stack Smashing\n";
      cout << "5. Heap Spraying\n"; 
      cout << "6. Integer Overflow\n";
      cout << "7. ANSI-Unicode Conversion\n";
      cout << "8. None. Exit Program.\n";
      cin >> exploitTypeOption;
      switch (exploitTypeOption) {
         case '1':
            cout << "Array working example:\n";
            arrayWorking();
            cout << "Array exploit example:\n";
            arrayExploit();
            cout << endl;
            break;
         case '2':
            cout << "Arc working example:\n";
            arcWorking();
            cout << "Arc exploit example:\n";
            arcExploit();
            cout << endl;
            break;
         case '3':
            cout << "V-Table working example:\n";
            vtableWorking();
            cout << "V-Table exploit example:\n";
            vtableExploit();
            cout << endl;
            break;
         case '4':
            cout << "Stack working example:\n";
            stackWorking();
            cout << "Stack exploit example:\n";
            stackExploit();
            cout << endl;
            break;
         case '5':
            cout << "Heap working example:\n";
            heapWorking();
            cout << "Heap exploit example:\n";
            heapExploit();
            cout << endl;
            break;
         case '6':
            cout << "Integer working example:\n";
            integerWorking();
            cout << "Integer exploit example:\n";
            integerExploit();
            cout << endl;
            break;
         case '7':
            cout << "ANSI working example:\n";
            ansiWorking();
            cout << "ANSI exploit example:\n";
            ansiExploit();
            break;
         case '8':
            break;
         default:
            cout << "Not a valid option. Enter a number 1 through 7.\n";
            break;
      }
   }
}